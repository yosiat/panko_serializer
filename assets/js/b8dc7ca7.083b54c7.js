"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[12],{8451:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"response-bag","title":"Response","description":"Let\'s say you have some JSON payload which is constructed using Panko serialization result,","source":"@site/docs/response-bag.md","sourceDirName":".","slug":"/response-bag","permalink":"/response-bag","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"response-bag","title":"Response","sidebar_label":"Response"},"sidebar":"docs","previous":{"title":"Associations","permalink":"/associations"}}');var t=s(4848),r=s(8453);const a={id:"response-bag",title:"Response",sidebar_label:"Response"},i=void 0,l={},c=[{value:"JsonValue",id:"jsonvalue",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Let's say you have some JSON payload which is constructed using Panko serialization result,\nlike this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"\nclass PostsController < ApplicationController\n  def index\n   posts = Post.all\n   render json: {\n     success: true,\n     total_count: posts.count,\n     posts: Panko::ArraySerializer.new(posts, each_serializer: PostSerializer).to_json\n   }\n  end\nend\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The output of the above will be a JSON string (for ",(0,t.jsx)(n.code,{children:"posts"}),") inside a JSON string and this were ",(0,t.jsx)(n.code,{children:"Panko::Response"})," shines."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"\nclass PostsController < ApplicationController\n  def index\n   posts = Post.all\n   render json: Panko::Response.new(\n     success: true,\n     total_count: posts.count,\n     posts: Panko::ArraySerializer.new(posts, each_serializer: PostSerializer)\n   )\n  end\nend\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"And everything will work as expected!"}),"\n",(0,t.jsxs)(n.p,{children:["For a single object serialization, we need to use a different API (since ",(0,t.jsx)(n.code,{children:"Panko::Serializer"})," doesn't accept an object in it's constructor):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"\nclass PostsController < ApplicationController\n  def show\n    post = Post.find(params[:id])\n\n    render(\n      json: Panko::Response.create do |r|\n        {\n          success: true,\n          post: r.serializer(post, PostSerializer)\n        }\n      end\n    )\n  end\nend\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"jsonvalue",children:"JsonValue"}),"\n",(0,t.jsxs)(n.p,{children:["Let's take the above example further, we will serialize the posts and cache it as JSON string in our Cache.\nNow, you can wrap the cached value with ",(0,t.jsx)(n.code,{children:"Panko::JsonValue"}),", like here:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'\nclass PostsController < ApplicationController\n  def index\n   posts = Cache.get("/posts")\n\n   render json: Panko::Response.new(\n     success: true,\n     total_count: posts.count,\n     posts: Panko::JsonValue.from(posts)\n   )\n  end\nend\n\n'})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var o=s(6540);const t={},r=o.createContext(t);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);