"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[552],{3602:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"attributes","title":"Attributes","description":"Attributes allow you to specify which record attributes you want to serialize.","source":"@site/docs/attributes.md","sourceDirName":".","slug":"/attributes","permalink":"/attributes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"attributes","title":"Attributes","sidebar_label":"Attributes"},"sidebar":"docs","previous":{"title":"Design Choices","permalink":"/design-choices"},"next":{"title":"Associations","permalink":"/associations"}}');var i=n(4848),r=n(8453);const a={id:"attributes",title:"Attributes",sidebar_label:"Attributes"},l=void 0,o={},c=[{value:"Field Attributes",id:"field-attributes",level:2},{value:"Method Attributes",id:"method-attributes",level:2},{value:"Filters",id:"filters",level:2},{value:"Filters For",id:"filters-for",level:2},{value:"Aliases",id:"aliases",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Attributes allow you to specify which record attributes you want to serialize."}),"\n",(0,i.jsx)(t.p,{children:"There are two types of attributes:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Field - simple columns defined on the record it self."}),"\n",(0,i.jsx)(t.li,{children:"Virtual/Method - this allows to include properties beyond simple fields."}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:'\nclass UserSerializer < Panko::Serializer\n  attributes :full_name\n\n  def full_name\n    "#{object.first_name} #{object.last_name}"\n   end\nend\n\n'})}),"\n",(0,i.jsx)(t.h2,{id:"field-attributes",children:"Field Attributes"}),"\n",(0,i.jsx)(t.p,{children:"Using field attributes you can control which columns of the given ActiveRecord object you want to serialize."}),"\n",(0,i.jsxs)(t.p,{children:["Instead of relying on ActiveRecord to do it's type casting, Panko does on it's own for performance reasons (read more in ",(0,i.jsx)(t.a,{href:"/design-choices#type-casting",children:"Design Choices"}),")."]}),"\n",(0,i.jsx)(t.h2,{id:"method-attributes",children:"Method Attributes"}),"\n",(0,i.jsx)(t.p,{children:"Method attributes are used when your serialized values can be derived from the object you are serializing."}),"\n",(0,i.jsxs)(t.p,{children:["The serializer's attribute methods can access the object being serialized as ",(0,i.jsx)(t.code,{children:"object"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:'\nclass PostSerializer < Panko::Serializer\n  attributes :author_name\n\n  def author_name\n    "#{object.author.first_name} #{object.author.last_name}"\n  end\nend\n\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Another useful thing you can pass your serializer is ",(0,i.jsx)(t.code,{children:"context"}),", a ",(0,i.jsx)(t.code,{children:"context"})," is a bag of data whom your serializer may need."]}),"\n",(0,i.jsx)(t.p,{children:"For example, here we will pass feature flags:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"\nclass UserSerializer < Panko::Serializer\n  attributes :id, :email\n\n  def feature_flags\n    context[:feature_flags]\n  end\nend\n\nserializer = UserSerializer.new(context: {\n  feature_flags: FeatureFlags.all\n})\n\nserializer.serialize(User.first)\n\n"})}),"\n",(0,i.jsx)(t.h2,{id:"filters",children:"Filters"}),"\n",(0,i.jsx)(t.p,{children:"Filters allows us to reduce the amount of attributes we can serialize, therefore reduce the data usage & performance of serializing."}),"\n",(0,i.jsx)(t.p,{children:"There are two types of filters:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["only - use those attributes ",(0,i.jsx)(t.strong,{children:"only"})," and nothing else."]}),"\n",(0,i.jsxs)(t.li,{children:["except - all attributes ",(0,i.jsx)(t.strong,{children:"except"})," those attributes."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Usage example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"\nclass UserSerializer < Panko::Serializer\n  attributes :id, :name, :email\nend\n\n# this line will return { 'name': '..' }\nUserSerializer.new(only: [:name]).serialize(User.first)\n\n# this line will return { 'id': '..', 'email': ... }\nUserSerializer.new(except: [:name]).serialize(User.first)\n\n"})}),"\n",(0,i.jsxs)(t.p,{children:["> ",(0,i.jsx)(t.strong,{children:"Note"})," that if you want to user filter on an associations, the ",(0,i.jsx)(t.code,{children:":name"})," property is not taken into account.\nIf you have a ",(0,i.jsx)(t.code,{children:"has_many :state_transitions, name: :history"})," association defined, the key to use in filters is\n",(0,i.jsx)(t.code,{children:":state_transitions"})," (e.g. ",(0,i.jsx)(t.code,{children:"{ except: [:state_transitions] }"}),")."]}),"\n",(0,i.jsx)(t.h2,{id:"filters-for",children:"Filters For"}),"\n",(0,i.jsx)(t.p,{children:"Sometimes you find yourself having the same filtering logic in actions. In order to\nsolve this duplication, Panko allows you to write the filters in the serializer."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"\nclass UserSerializer < Panko::Serializer\n  attributes :id, :name, :email\n\n  def self.filters_for(context, scope)\n    {\n      only: [:name]\n    }\n  end\nend\n\n# this line will return { 'name': '..' }\nUserSerializer.serialize(User.first)\n\n"})}),"\n",(0,i.jsxs)(t.p,{children:["> See discussion in: ",(0,i.jsx)(t.a,{href:"https://github.com/yosiat/panko_serializer/issues/16",children:"https:"})]}),"\n",(0,i.jsx)(t.h2,{id:"aliases",children:"Aliases"}),"\n",(0,i.jsx)(t.p,{children:"Let's say we have an attribute name that we want to expose to client as different name, the current way of doing so is using method attribute, for example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"\nclass PostSerializer < Panko::Serializer\n  attributes :published_at\n\n  def published_at\n    object.created_at\n  end\nend\n\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The downside of this approach is that ",(0,i.jsx)(t.code,{children:"created_at"})," skips Panko's type casting, therefore we get a direct hit on performance."]}),"\n",(0,i.jsx)(t.p,{children:"To fix this, we can use aliases:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"\nclass PostSerializer < Panko::Serializer\n  aliases created_at: :published_at\nend\n\n"})})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);