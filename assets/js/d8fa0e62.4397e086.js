"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[781],{5706:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"design-choices","title":"Design Choices","description":"In short, Panko, is a serializer for ActiveRecord objects (it can\'t serialize any other object), which strives for high performance & simple API (which is inspired by ActiveModelSerializers).","source":"@site/docs/design-choices.md","sourceDirName":".","slug":"/design-choices","permalink":"/design-choices","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"design-choices","title":"Design Choices","sidebar_label":"Design Choices"},"sidebar":"docs","previous":{"title":"Performance","permalink":"/performance"},"next":{"title":"Attributes","permalink":"/attributes"}}');var s=t(4848),r=t(8453);const a={id:"design-choices",title:"Design Choices",sidebar_label:"Design Choices"},o=void 0,l={},c=[{value:"Serialization overview",id:"serialization-overview",level:2},{value:"Interesting parts",id:"interesting-parts",level:2},{value:"Oj::StringWriter",id:"ojstringwriter",level:3},{value:"Figuring out the metadata, ahead of time.",id:"figuring-out-the-metadata-ahead-of-time",level:3},{value:"Type Casting",id:"type-casting",level:3},{value:"Time type casting",id:"time-type-casting",level:4}];function d(e){const i={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:"In short, Panko, is a serializer for ActiveRecord objects (it can't serialize any other object), which strives for high performance & simple API (which is inspired by ActiveModelSerializers)."}),"\n",(0,s.jsx)(i.p,{children:"Its performance is achieved by:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"Oj::StringWriter"})," - I will elaborate later."]}),"\n",(0,s.jsx)(i.li,{children:"Type casting \u2014 instead of relying on ActiveRecord to do its type cast, Panko is doing it by itself."}),"\n",(0,s.jsxs)(i.li,{children:["Figuring out the metadata, ahead of time \u2014 therefore, we ask less questions during the ",(0,s.jsx)(i.code,{children:"serialization loop"}),"."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"serialization-overview",children:"Serialization overview"}),"\n",(0,s.jsxs)(i.p,{children:["First, let's start with overview. Let's say we want to serialize ",(0,s.jsx)(i.code,{children:"User"})," object, which has\n",(0,s.jsx)(i.code,{children:"first_name"}),", ",(0,s.jsx)(i.code,{children:"last_name"}),", ",(0,s.jsx)(i.code,{children:"age"}),", and ",(0,s.jsx)(i.code,{children:"email"})," properties."]}),"\n",(0,s.jsx)(i.p,{children:"The serializer definition will be something like this:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-ruby",children:'\nclass UserSerializer < Panko::Serializer\n  attributes :name, :age, :email\n  \n  def name\n    "#{object.first_name} #{object.last_name}"\n  end\nend\n\n'})}),"\n",(0,s.jsx)(i.p,{children:"And the usage of this serializer will be:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-ruby",children:"\n# fetch user from database\nuser = User.first\n\n# create serializer, with empty options\nserializer = UserSerializer.new\n\n# serialize to JSON\nserializer.serialize_to_json(user)\n\n"})}),"\n",(0,s.jsxs)(i.p,{children:["Let's go over the steps that Panko will execute behind the scenes for this flow.\n",(0,s.jsxs)(i.em,{children:["I will skip the serializer definition part, because it's fairly simple and straightforward (see ",(0,s.jsx)(i.code,{children:"lib/panko/serializer.rb"}),")"]})]}),"\n",(0,s.jsxs)(i.p,{children:["First step, while initializing the UserSerializer, we will create a ",(0,s.jsx)(i.strong,{children:"Serialization Descriptor"})," for this class.\nSerialization Descriptor's goal is to answer those questions:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Which fields do we have? In our case, ",(0,s.jsx)(i.code,{children:":age"}),", ",(0,s.jsx)(i.code,{children:":email"})]}),"\n",(0,s.jsxs)(i.li,{children:["Which method fields do we have? In our case ",(0,s.jsx)(i.code,{children:":name"})]}),"\n",(0,s.jsx)(i.li,{children:"Which associations do we have (and their serialization descriptors)"}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["The serialization description is also responsible for filtering the attributes (",(0,s.jsx)(i.code,{children:"only"})," \\ ",(0,s.jsx)(i.code,{children:"except"}),")."]}),"\n",(0,s.jsxs)(i.p,{children:["Now, that we have the serialization descriptor, we are finished with the Ruby part of Panko, and all we did here is done in ",(0,s.jsx)(i.em,{children:"initialization time"})," and now we move to C code."]}),"\n",(0,s.jsxs)(i.p,{children:["In C land, we take the ",(0,s.jsx)(i.code,{children:"user"})," object and the serialization descriptor, and start the serialization process which is separated to 4 parts:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Serializing Fields - looping through serialization descriptor's ",(0,s.jsx)(i.code,{children:"fields"})," and read them from the ActiveRecord object (see ",(0,s.jsx)(i.code,{children:"Type Casting"}),") and write them to the writer."]}),"\n",(0,s.jsxs)(i.li,{children:["Serializing Method Fields - creating (a cached) serializer instance, setting its ",(0,s.jsx)(i.code,{children:"@object"})," and ",(0,s.jsx)(i.code,{children:"@context"}),", calling all the method fields and writing them to the writer."]}),"\n",(0,s.jsx)(i.li,{children:"Serializing associations \u2014 this is simple, once we have fields + method fields, we just repeat the process."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Once this is finished, we have nice JSON string.\nNow let's dig deeper."}),"\n",(0,s.jsx)(i.h2,{id:"interesting-parts",children:"Interesting parts"}),"\n",(0,s.jsx)(i.h3,{id:"ojstringwriter",children:"Oj::StringWriter"}),"\n",(0,s.jsx)(i.p,{children:"If you read the code of ActiveRecord serialization code in Ruby, you will observe this flow:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["Get an array of ActiveRecord objects (",(0,s.jsx)(i.code,{children:"User.all"})," for example)"]}),"\n",(0,s.jsxs)(i.li,{children:["Build new array of hashes where each hash is ",(0,s.jsx)(i.code,{children:"User"})," with the attributes we selected"]}),"\n",(0,s.jsx)(i.li,{children:"The JSON serializer, takes this array of hashes and loop them, and converts it to JSON string"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This entire process is expensive in terms of Memory & CPU, and this where the combination of Panko and Oj::StringWriter really shines."}),"\n",(0,s.jsx)(i.p,{children:"In Panko, the serialization process of the above is:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["Get an array of ActiveRecord objects (",(0,s.jsx)(i.code,{children:"User.all"})," for example)"]}),"\n",(0,s.jsxs)(i.li,{children:["Create ",(0,s.jsx)(i.code,{children:"Oj::StringWriter"})," and feed the values to it, via ",(0,s.jsx)(i.code,{children:"push_value"})," / ",(0,s.jsx)(i.code,{children:"push_object"})," / ",(0,s.jsx)(i.code,{children:"push_object"})," and behind the scene, ",(0,s.jsx)(i.code,{children:"Oj::StringWriter"})," will serialize the objects incrementally into a string."]}),"\n",(0,s.jsxs)(i.li,{children:["Get from ",(0,s.jsx)(i.code,{children:"Oj::StringWriter"})," the completed JSON string \u2014 which is a no-op, since ",(0,s.jsx)(i.code,{children:"Oj::StringWriter"})," already built the string."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"figuring-out-the-metadata-ahead-of-time",children:"Figuring out the metadata, ahead of time."}),"\n",(0,s.jsx)(i.p,{children:"Another observation I noticed in the ruby serializers is that they ask and do a lot in a serialization loop:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Is this field a method? is it a property?"}),"\n",(0,s.jsxs)(i.li,{children:["Which fields and associations do I need for the serializer to consider the ",(0,s.jsx)(i.code,{children:"only"})," and ",(0,s.jsx)(i.code,{children:"except"})," options"]}),"\n",(0,s.jsx)(i.li,{children:"What is the serializer of this has_one association?"}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["Panko tries to ask the bare minimum in serialization by building ",(0,s.jsx)(i.code,{children:"Serialization Descriptor"})," for each serialization and caching it."]}),"\n",(0,s.jsxs)(i.p,{children:["The Serialization Descriptor will do the filtering of ",(0,s.jsx)(i.code,{children:"only"})," and ",(0,s.jsx)(i.code,{children:"except"})," and will check if a field is a method or not (therefore Panko doesn't have list of ",(0,s.jsx)(i.code,{children:"attributes"}),")"]}),"\n",(0,s.jsx)(i.h3,{id:"type-casting",children:"Type Casting"}),"\n",(0,s.jsx)(i.p,{children:"This is the final part, which helped yield most of the performance improvements.\nIn ActiveRecord, when we read a value of attribute, it does type casting of the DB value to its real ruby type."}),"\n",(0,s.jsx)(i.p,{children:"For example, time strings are converted to Time objects, Strings are duplicated, and Integers are converts from their values to Number."}),"\n",(0,s.jsx)(i.p,{children:'This type casting is really expensive, as it\'s responsible for most of the allocations in the serialization flow and most of them can be "relaxed".'}),"\n",(0,s.jsx)(i.p,{children:"If we think about it, we don't need to duplicate strings or convert time strings to time objects or even parse JSON strings for the JSON serialization process."}),"\n",(0,s.jsx)(i.p,{children:"What Panko does is that if we have ActiveRecord type string, we won't duplicate it.\nIf we have an integer string value, we will convert it to an integer, and the same goes for other types."}),"\n",(0,s.jsx)(i.p,{children:"All of these conversions are done in C, which of course yields a big performance improvement."}),"\n",(0,s.jsx)(i.h4,{id:"time-type-casting",children:"Time type casting"}),"\n",(0,s.jsx)(i.p,{children:'While you read Panko source code, you will encounter the time type casting and immediately you will have a "WTF?" moment.'}),"\n",(0,s.jsx)(i.p,{children:"The idea behind the time type casting code relies on the end result of JSON type casting \u2014 what we need in order to serialize Time to JSON? UTC ISO8601 time format representation."}),"\n",(0,s.jsx)(i.p,{children:"The time type casting works as follows:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["If it's a string that ends with ",(0,s.jsx)(i.code,{children:"Z"}),", and the strings matches the UTC ISO8601 regex, then we just return the string."]}),"\n",(0,s.jsx)(i.li,{children:"If it's a string and it doesn't follow the rules above, we check if it's a timestamp in database format and convert it via regex + string concat to UTC ISO8601 - Yes, there is huge assumption here, that the database returns UTC timestamps \u2014 this will be configureable (before Panko official release)."}),"\n",(0,s.jsx)(i.li,{children:"If it's none of the above, I will let ActiveRecord type casting do it's magic."}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>o});var n=t(6540);const s={},r=n.createContext(s);function a(e){const i=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);