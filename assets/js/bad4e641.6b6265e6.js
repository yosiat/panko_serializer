"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[552],{3602:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"attributes","title":"Attributes","description":"Attributes allow you to specify which record attributes you want to serialize,","source":"@site/docs/attributes.md","sourceDirName":".","slug":"/attributes","permalink":"/attributes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"attributes","title":"Attributes","sidebar_label":"Attributes"},"sidebar":"docs","previous":{"title":"Design Choices","permalink":"/design-choices"},"next":{"title":"Associations","permalink":"/associations"}}');var s=t(4848),r=t(8453);const a={id:"attributes",title:"Attributes",sidebar_label:"Attributes"},l=void 0,o={},c=[{value:"Field Attributes",id:"field-attributes",level:2},{value:"Method Attributes",id:"method-attributes",level:2},{value:"Filters",id:"filters",level:2},{value:"Filters For",id:"filters-for",level:2},{value:"Aliases",id:"aliases",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Attributes allow you to specify which record attributes you want to serialize,\nThere are two types of attributes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Field - simple columns defined on the record it self."}),"\n",(0,s.jsx)(n.li,{children:"Virtual/Method - this allows to include properties beyond simple fields."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'\nclass UserSerializer < Panko::Serializer\n  attributes :full_name\n\n  def full_name\n    "#{object.first_name} #{object.last_name}"\n   end\nend\n\n'})}),"\n",(0,s.jsx)(n.h2,{id:"field-attributes",children:"Field Attributes"}),"\n",(0,s.jsx)(n.p,{children:"Using field attributes you can control which columns of the given ActiveRecord object you want to serialize."}),"\n",(0,s.jsxs)(n.p,{children:["Instead of relying ActiveRecord to do it's type casting, Panko does on it's own for performance reasons (read more in ",(0,s.jsx)(n.a,{href:"/design-choices#type-casting",children:"Design Choices"}),")."]}),"\n",(0,s.jsx)(n.h2,{id:"method-attributes",children:"Method Attributes"}),"\n",(0,s.jsx)(n.p,{children:"Method attributes are used when your serialized values can be derived from the object you are serializing."}),"\n",(0,s.jsxs)(n.p,{children:["The serializer's attribute methods can access the object being serialized as ",(0,s.jsx)(n.code,{children:"object"})," -"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'\nclass PostSerializer < Panko::Serializer\n  attributes :author_name\n\n  def author_name\n    "#{object.author.first_name} #{object.author.last_name}"\n  end\nend\n\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Another useful, thing you can pass your serializer is ",(0,s.jsx)(n.code,{children:"context"}),", a ",(0,s.jsx)(n.code,{children:"context"})," is a bag of data whom your serializer may need."]}),"\n",(0,s.jsx)(n.p,{children:"For example, here we will pass feature flags:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"\nclass UserSerializer < Panko::Serializer\n  attributes :id, :email\n\n  def feature_flags\n    context[:feature_flags]\n  end\nend\n\nserializer = UserSerializer.new(context: {\n  feature_flags: FeatureFlags.all\n})\n\nserializer.serialize(User.first)\n\n"})}),"\n",(0,s.jsx)(n.h2,{id:"filters",children:"Filters"}),"\n",(0,s.jsx)(n.p,{children:"Filters allows us to reduce the amount of attributes we can serialize, therefore reduce the data usage & performance of serializing."}),"\n",(0,s.jsx)(n.p,{children:"There are two types of filters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["only - use those attributes ",(0,s.jsx)(n.strong,{children:"only"})," and nothing else"]}),"\n",(0,s.jsxs)(n.li,{children:["except - all attributes ",(0,s.jsx)(n.strong,{children:"except"})," those attributes"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Usage example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"\nclass UserSerializer < Panko::Serializer\n  attributes :id, :name, :email\nend\n\n# this line will return { 'name': '..' }\nUserSerializer.new(only: [:name]).serialize(User.first)\n\n# this line will return { 'id': '..', 'email': ... }\nUserSerializer.new(except: [:name]).serialize(User.first)\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["> ",(0,s.jsx)(n.strong,{children:"Note"})," that if you want to user filter on an associations, the ",(0,s.jsx)(n.code,{children:":name"}),"\n> property is not taken into account.\n> If you have a ",(0,s.jsx)(n.code,{children:"has_many :state_transitions, name: :history"})," association\n> defined, the key to use in filters is ",(0,s.jsx)(n.code,{children:":state_transitions"}),"\n> (e.g. ",(0,s.jsx)(n.code,{children:"{ except: [:state_transitions] }"}),")"]}),"\n",(0,s.jsx)(n.h2,{id:"filters-for",children:"Filters For"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you find yourself have the same filtering logic in actions in order to\nsolve this duplication, Panko allows you to write the filters in the serializer."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"\nclass UserSerializer < Panko::Serializer\n  attributes :id, :name, :email\n\n  def self.filters_for(context, scope)\n    {\n      only: [:name]\n    }\n  end\nend\n\n# this line will return { 'name': '..' }\nUserSerializer.serialize(User.first)\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"> See discussion in: https:"}),"\n",(0,s.jsx)(n.h2,{id:"aliases",children:"Aliases"}),"\n",(0,s.jsx)(n.p,{children:"Let's say we have attribute name that we want to expose to client as different name, the current way of doing so is using method attribute, for example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"\n\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"The downside of this approach is that `` skips Panko's type casting, therefore we get direct hit on performance."}),"\n",(0,s.jsx)(n.p,{children:"To fix this, we can use aliases -"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"\n\n\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);