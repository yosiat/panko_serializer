"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[657],{8178:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"associations","title":"Associations","description":"A serializer can define it\'s own associations - both hasmany and hasone to serialize under the context of the object.","source":"@site/docs/associations.md","sourceDirName":".","slug":"/associations","permalink":"/associations","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"associations","title":"Associations","sidebar_label":"Associations"},"sidebar":"docs","previous":{"title":"Attributes","permalink":"/attributes"},"next":{"title":"Response","permalink":"/response-bag"}}');var t=s(4848),a=s(8453);const o={id:"associations",title:"Associations",sidebar_label:"Associations"},r=void 0,l={},c=[{value:"Associations with aliases",id:"associations-with-aliases",level:3},{value:"Inference",id:"inference",level:3},{value:"Nested Filters",id:"nested-filters",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["A serializer can define it's own associations - both ",(0,t.jsx)(n.code,{children:"has_many"})," and ",(0,t.jsx)(n.code,{children:"has_one"})," to serialize under the context of the object."]}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"\nclass PostSerializer < Panko::Serializer\n  attributes :title, :body\n\n  has_one :author, serializer: AuthorSerializer\n  has_many :comments, each_serializer: CommentSerializer\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"associations-with-aliases",children:"Associations with aliases"}),"\n",(0,t.jsxs)(n.p,{children:["An association key name can be aliased with the ",(0,t.jsx)(n.code,{children:"name"})," option."]}),"\n",(0,t.jsxs)(n.p,{children:["For example:\nthe ",(0,t.jsx)(n.code,{children:"actual_author"})," property will be converted to ",(0,t.jsx)(n.code,{children:"alias_author"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"\nclass PostSerializer < Panko::Serializer\n  attributes :title, :body\n\n  has_one :actual_author, serializer: AuthorSerializer, name: :alias_author\n  has_many :comments, each_serializer: CommentSerializer\nend\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"inference",children:"Inference"}),"\n",(0,t.jsx)(n.p,{children:"Panko can find the type of the serializer by looking at the relationship name, so instead of specifying\nthe serializer at the above example, we can:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"\nclass PostSerializer < Panko::Serializer\n  attributes :title, :body\n\n  has_one :author\n  has_many :comments\nend\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"The logic of inferencing is:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Take the name of the relationship (for example - ",(0,t.jsx)(n.code,{children:":author"})," / ",(0,t.jsx)(n.code,{children:":comments"}),") singularize and camelize it."]}),"\n",(0,t.jsxs)(n.li,{children:['Look for const defined with the name above and "Serializer" suffix (by using ',(0,t.jsx)(n.code,{children:"Object.const_get"}),")."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["> If Panko can't find the serializer it will throw an error on startup time, for example: ",(0,t.jsx)(n.code,{children:"Can't find serializer for PostSerializer.author has_one relationship"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"nested-filters",children:"Nested Filters"}),"\n",(0,t.jsx)(n.p,{children:"As talked before, Panko allows you to filter the attributes of a serializer.\nBut Panko lets you take that step further, and filters the attributes of you associations so you can re-use your serializers in your application."}),"\n",(0,t.jsxs)(n.p,{children:["For example, let's say one portion of the application needs to serialize a list of posts but only with their - ",(0,t.jsx)(n.code,{children:"title"}),", ",(0,t.jsx)(n.code,{children:"body"}),", author's id and comments id."]}),"\n",(0,t.jsxs)(n.p,{children:["We can declare tailored serializer for this, or we can re-use the above defined serializer - ",(0,t.jsx)(n.code,{children:"PostSerializer"})," and use nested filters."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"\nposts = Post.all\n\nPanko::ArraySerializer.new(posts, each_serializer: PostSerializer, only: {\n  instance: [:title, :body, :author, :comments],\n  author: [:id],\n  comments: [:id],\n})\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's dissect the ",(0,t.jsx)(n.code,{children:"only"})," option we passed:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"instance"})," - list of attributes (and associations) we want to serialize for the current instance of the serializer, in this case - ",(0,t.jsx)(n.code,{children:"PostSerializer"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"author"}),", ",(0,t.jsx)(n.code,{children:"comments"})," - here we specify the list of attributes we want to serialize for each association."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It's important to note that Nested Filters are recursive, in other words, we can filter the association's associations."}),"\n",(0,t.jsxs)(n.p,{children:["For example, ",(0,t.jsx)(n.code,{children:"CommentSerializer"})," has an ",(0,t.jsx)(n.code,{children:"has_one"})," association ",(0,t.jsx)(n.code,{children:"Author"}),", and for each ",(0,t.jsx)(n.code,{children:"comments.author"})," we can only serialize it's name."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"\nposts = Post.all\n\nPanko::ArraySerializer.new(posts, only: {\n  instance: [:title, :body, :author, :comments],\n  author: [:id],\n  comments: {\n    instance: [:id, :author],\n    author: [:name]\n  }\n})\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you see now in ",(0,t.jsx)(n.code,{children:"comments"})," the ",(0,t.jsx)(n.code,{children:"instance"})," have different meaning, the ",(0,t.jsx)(n.code,{children:"CommentSerializer"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var i=s(6540);const t={},a=i.createContext(t);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);